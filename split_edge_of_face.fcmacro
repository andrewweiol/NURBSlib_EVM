import Part
from FreeCAD import Base
from FreeCAD import Gui
import math
import BezCubic as BC

#select an edge, and the face it is a part of.
#must be a visible edge of the face,
#not an external curve, such as the guide used to build the face.
#TODO: refine selection to allow an external curve as the selected edge (check all poles).

#this script cuts the selected edge at the specified parameter, shows the iso curve orthogonal to the selected edges at the cutting point,
#and create three sketches which allow G1 curve>surface connections to the selected surface at:
#the two corners of the selected edges, AND
#the cut point on the edge

#
#	+++++++++++C++++++++++
#	+			+			+
#	+	surf		B+++++++++++
#	^			+			+
#	v	edge >	+			+
#	+u>+++++++A++++++++++
#



# process the selection
s=Gui.Selection.getSelectionEx()[0].SubObjects
edge=s[0]
face=s[1]
e_split=0.25 # parameter ratio at edge cut. this could set by mouse position, or a numeric entry, or whatever

#get the endpoints of the edge
curve=edge.Curve
curve_pts=[curve.StartPoint, curve.EndPoint]

# prepare a list of the surfaces edges references, identified by corner point pairs
surface=face.Surface

surf_poles=surface.getPoles()

p00=surf_poles[0][0]
p10=surf_poles[3][0]
p11=surf_poles[3][3]
p01=surf_poles[0][3]
surface_pts=[[p00,p10],[p10,p11],[p11,p01],[p01,p00]]

# find the target edge in the list, identify the the split direction, identify the parameter (min/max?) at the split.
if curve_pts in surface_pts: # selected edge is in the same orientation as target edge. this is for alternate selection methods for the edge. 
						#right now, as the edge came from the surface itself, it should always hold.
	match=surface_pts.index(curve_pts) # get index of matching edge in the surface
	if match == 0: # target edge is v_iso at v=0
		split=0 # the splitting curve will be a u_iso
		pin=0 # the intersection of the splitting curve and split edge is at parameter 0 along u (which puts it on the v=0 v_iso)
	elif match == 1: # target edge is u_iso at u=1
		split=1 # the splitting curve will be a v_iso
		pin=1 # the intersection of the splitting curve and split edge is at parameter 1 along u (which puts it on the u=1 u_iso)
	elif match == 2: # target edge is v_iso at v=1
		split=0 # the splitting curve will be a u_iso
		pin=1
	elif match == 3: # target edge is u_iso at u=0
		split=1 # the splitting curve will be a v_iso
		pin=0

elif curve_pts[::-1] in surface_pts: # selected edge is in the opposite orientation as target edge
	match=surface_pts.index(curve_pts[::-1])
	if match == 0:
		split=0
		pin=0
	elif match == 1:
		split=1
		pin=1
	elif match == 2:
		split=0
		pin=1
	elif match == 3:
		split=1
		pin=0

#find corners A, C, and their tangents pointing out of the face (these will loosely define the y axes of our sketches)
if split==0:
	if pin==0:
		A=surf_poles[0][0]
		A_tan_y=surf_poles[0][0]-surf_poles[0][1]
		C=surf_poles[3][0]
		C_tan_y=surf_poles[3][0]-surf_poles[3][1]
	elif pin==1:
		A=surf_poles[3][3]
		A_tan_y=surf_poles[3][3]-surf_poles[3][2]
		C=surf_poles[0][3]
		C_tan_y=surf_poles[0][3]-surf_poles[0][2]

elif split==1:
	if pin==0:
		A=surf_poles[0][3]
		A_tan_y=surf_poles[0][3]-surf_poles[1][3]
		C=surf_poles[0][0]
		C_tan_y=surf_poles[0][0]-surf_poles[1][0]
	elif pin==1:
		A=surf_poles[3][0]
		A_tan_y=surf_poles[3][0]-surf_poles[2][0]
		C=surf_poles[3][3]
		C_tan_y=surf_poles[3][3]-surf_poles[2][3]

##############################################################################	
#test section
A_y=Part.Line(A, A+A_tan_y)
C_y=Part.Line(C, C+C_tan_y)		
Part.show(A_y.toShape())
Part.show(C_y.toShape())
#end test section
##############################################################################

# determine the splitting parameter as applied to u or v
bounds=surface.bounds() # returns (u_min, u_max, v_min, v_max)
if split==0:
	p_split=(bounds[1]-bounds[0])*e_split # ratio applied to actual u domain
elif split==1:
	p_split=(bounds[3]-bounds[2])*e_split # ratio applied to actual v domain

# create the iso curve that splits the face, and the edge curve which will be cut in two
if split==0:
	face_split=surface.uIso(p_split)
	#prepare two copies to avoid passing by reference later
	#this is temporary, copy() function is not available on windows version 0.15
	edge_to_split_0=surface.vIso(bounds[pin+2])
	edge_to_split_1=surface.vIso(bounds[pin+2])
elif split==1:
	face_split=surface.vIso(p_split)
	#prepare two copies to avoid passing by reference later
	#this is temporary, copy() function is not available on windows version 0.15
	edge_to_split_0=surface.uIso(bounds[pin])
	edge_to_split_1=surface.uIso(bounds[pin])


#check the edge parameters. not sure if can use p_split directly here, because the first and last parameters are explicitly needed.
u0=edge_to_split_0.FirstParameter
u1=edge_to_split_1.LastParameter

#trim the copies of the selected edge
edge_to_split_0.segment(u0,p_split)
edge_to_split_1.segment(p_split, u1)

# rename clipped edges to mark the step - necessary because the segment() function passes by references
edge_split_0p=edge_to_split_0
edge_split_p1=edge_to_split_1

##############################################################################
#test section
Part.show(face_split.toShape())
Part.show(edge_split_0p.toShape())
Part.show(edge_split_p1.toShape())
#end test section
##############################################################################

#extract poles from the splitter an split curves
face_split_poles=face_split.getPoles()
edge_split_0p_poles=edge_split_0p.getPoles()
edge_split_p1_poles=edge_split_p1.getPoles()

#find corners B and its projected tangent pointing out of the face (this will loosely define the y axis of our sketch)
if pin==0:
	B=face_split_poles[0] #first
	B_tan_y=face_split_poles[0]-face_split_poles[1] 
elif pin==1:
	B=face_split_poles[3] #last
	B_tan_y=face_split_poles[3]-face_split_poles[2]

##############################################################################
#test section
B_y=Part.Line(B, B+B_tan_y)
Part.show(B_y.toShape())
#end test section
##############################################################################

#find all the tangents along the split edge (these will exactly define the x axes of our sketches)
if split==pin: #natural edge parameter follows the intended ABC order
	A_check=edge_split_0p_poles[0]
	A_tan_x=edge_split_0p_poles[1]-edge_split_0p_poles[0]
	B_check=edge_split_0p_poles[3]
	B_tan_x_A=edge_split_0p_poles[2]-edge_split_0p_poles[3]
	B_tan_x_C=edge_split_p1_poles[1]-edge_split_p1_poles[0]
	C_check=edge_split_p1_poles[3]
	C_tan_x=edge_split_p1_poles[2]-edge_split_p1_poles[3]
	
elif split!=pin:
	A_check=edge_split_p1_poles[3]
	A_tan_x=edge_split_p1_poles[2]-edge_split_p1_poles[3]
	B_check=edge_split_p1_poles[0]
	B_tan_x_A=edge_split_p1_poles[1]-edge_split_p1_poles[0]
	B_tan_x_C=edge_split_0p_poles[2]-edge_split_0p_poles[3]
	C_check=edge_split_0p_poles[0]
	C_tan_x=edge_split_0p_poles[1]-edge_split_0p_poles[0]

##############################################################################
#test section
A_x=Part.Line(A_check, A_check+A_tan_x)
B_x_A=Part.Line(B_check, B_check+B_tan_x_A)
B_x_C=Part.Line(B_check, B_check+B_tan_x_C)
C_x=Part.Line(C_check, C_check+C_tan_x)
Part.show(A_x.toShape())
Part.show(B_x_A.toShape())
Part.show(B_x_C.toShape())
Part.show(C_x.toShape())
#end test section
##############################################################################

sketch_A_x=A_tan_x.normalize()			# the actual x direction of the sketch
sketch_A_y_temp=Base.Vector(0,0,0)-A_tan_y.normalize()		#  something vaguely in the sketch's y direction
sketch_A_z=A_tan_x.cross(sketch_A_y_temp).normalize()				#the actual z direction of the sketch
sketch_A_y=sketch_A_z.cross(sketch_A_x).normalize()			#the actual sketch's y direction


##############################################################################
#test section
sA_x=Part.Line(A_check, A_check+sketch_A_x)
sA_y=Part.Line(A_check, A_check+sketch_A_y.scale(2,2,2))
sA_z=Part.Line(A_check, A_check+sketch_A_z.scale(3,3,3))
Part.show(sA_x.toShape())
Part.show(sA_y.toShape())
Part.show(sA_z.toShape())
#end test section
##############################################################################

sketch_A_matrix=App.Matrix(sketch_A_x.x,sketch_A_y.x,sketch_A_z.x,A.x,
						sketch_A_x.y,sketch_A_y.y,sketch_A_z.y,A.y,
						sketch_A_x.z,sketch_A_y.z,sketch_A_z.z,A.z,
						0,0,0,1)

App.activeDocument().addObject('Sketcher::SketchObject','node_A')
App.ActiveDocument.node_A.Placement=App.Placement(sketch_A_matrix)
App.ActiveDocument.node_A.addGeometry(Part.Circle())
App.ActiveDocument.node_A.addGeometry(Part.Line(Base.Vector(1,0,0),Base.Vector(2,0,0)))
App.ActiveDocument.node_A.addGeometry(Part.Line(Base.Vector(0,-1,0),Base.Vector(0,-2,0)))
App.ActiveDocument.recompute()

''' this snippet from an old file shows how to use intersect 2d
lax=Part.Line(pa1,pa3)
	lbx=Part.Line(pb1,pb3)
	pln=Part.Plane(pa1,pb1,pa2)
	int_0_1= lax.intersect2d(lbx,pln) #works down to 5.73 degrees between the lines 
	if int_0_1==[]:
		return 'intersection failed'
	int_abs_coord=pln.value(int_0_1[0][0],int_0_1[0][1]) 
'''

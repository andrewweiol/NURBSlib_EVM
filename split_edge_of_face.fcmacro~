import Part
from FreeCAD import Base
from FreeCAD import Gui
import math
import BezCubic as BC

#select an edge, and the face it is a part of.
#must be a visible edge of the face, 
#not an external curve, such as the guide used to build the face.

#this script cuts the selected edge at the specified parameter, shows the iso curve orthogonal to the selected edges at the cutting point,
#and create three sketches which allow G1 connection to the selected surface at:
#the two corners of the selected edges, AND
#the cut point on the edge

#
#	+++++++++++C++++++++++
#	+			+			+
#	+	surf		B+++++++++++
#	^			+			+
#	v	edge >	+			+
#	+u>+++++++A++++++++++
#

#TODO: refine selection to allow an external curve (check all poles)

# process the selection
s=Gui.Selection.getSelectionEx()[0].SubObjects
edge=s[0]
face=s[1]
e_split=0.25 # parameter ratio at edge cut. this could set by mouse position, or a numeric entry, or whatever

#get the endpoints of the edge
curve=edge.Curve
curve_pts=[curve.StartPoint, curve.EndPoint]

# prepare a list of the surfaces edges references, identified by corner point pairs
surface=face.Surface

surf_poles=surface.getPoles()

p00=surf_poles[0][0]
p10=surf_poles[0][3]
p11=surf_poles[3][3]
p01=surf_poles[3][0]
surface_pts=[[p00,p10],[p10,p11],[p11,p01],[p01,p00]]

# find the target edge in the list, identify the the split direction, identify the parameter (min/max?) at the split.
if curve_pts in surface_pts: # selected edge is in the same orientation as target edge. this is precautionary, to be ready for alternate selection methods for the edge. 
						#right now, as the edge came from the surface itself, it should always hold.
						#apparently, u and v are switched from what i thought.
	match=surface_pts.index(curve_pts) # get index of matching edge in the surface
	if match == 0: # target edge is v_iso at v=0
		split=0 # the splitting curve will be a u_iso
		pin=0 # the intersection of the splitting curve and split edge is at parameter 0 along u (which puts it on the v=0 v_iso)
	elif match == 1: # target edge is u_iso at u=1
		split=1 # the splitting curve will be a v_iso
		pin=1 # the intersection of the splitting curve and split edge is at parameter 1 along u (which puts it on the u=1 u_iso)
	elif match == 2: # target edge is v_iso at v=1
		split=0 # the splitting curve will be a u_iso
		pin=1
	elif match == 3: # target edge is u_iso at u=0
		split=1 # the splitting curve will be a v_iso
		pin=0

elif curve_pts[::-1] in surface_pts: # selected edge is in the opposite orientation as target edge
	match=surface_pts.index(curve_pts[::-1])
	if match == 0:
		split=0
		pin=0
	elif match == 1:
		split=1
		pin=1
	elif match == 2:
		split=0
		pin=1
	elif match == 3:
		split=1
		pin=0

#find corners A, C, and their projected tangents pointing out of the face (these will define the y axis of our sketches)
#i had to swap A and C from what i thought would be true....uv flipping again.
if split==0:
	if pin==0:
		C=surf_poles[0][0]
		C_tan_y=surf_poles[1][0]-surf_poles[0][0]
		A=surf_poles[0][3]
		A_tan_y=surf_poles[1][3]-surf_poles[0][3]
	elif pin==1:
		C=surf_poles[3][3]
		C_tan_y=surf_poles[2][3]-surf_poles[3][3]
		A=surf_poles[3][0]
		A_tan_y=surf_poles[2][0]-surf_poles[3][0]

elif split==1:
	if pin==0:
		C=surf_poles[3][0]
		C_tan_y=surf_poles[3][1]-surf_poles[3][0]
		A=surf_poles[0][0]
		A_tan_y=surf_poles[0][1]-surf_poles[0][0]
	elif pin==1:
		C=surf_poles[0][3]
		C_tan_y=surf_poles[0][2]-surf_poles[0][3]
		A=surf_poles[3][3]
		A_tan_y=surf_poles[3][2]-surf_poles[3][3]

##############################################################################	
#test section
A_y=Part.Line(A, A-A_tan_y)
C_y=Part.Line(C, C-C_tan_y)		
Part.show(A_y.toShape())
Part.show(C_y.toShape())
#end test section
##############################################################################

# determine the splitting parameter as applied to u or v
bounds=surface.bounds() # returns (u_min, u_max, v_min, v_max)
if split==0:
	p_split=(bounds[1]-bounds[0])*e_split # ratio applied to actual u domain
elif split==1:
	p_split=(bounds[3]-bounds[2])*e_split # ratio applied to actual v domain

# create the iso curve that splits the face, and the edge curve which will be cut in two
# u and v are reversed from what i expected, but whatever, i guess?
if split==0:
	face_split=surface.vIso(p_split)
	#prepare two copies to avoid passing by reference later
	#this is temporary, copy() function is not available on windows version 0.15
	edge_to_split_0=surface.uIso(bounds[pin+2])
	edge_to_split_1=surface.uIso(bounds[pin+2])
elif split==1:
	face_split=surface.uIso(p_split)
	#prepare two copies to avoid passing by reference later
	#this is temporary, copy() function is not available on windows version 0.15
	edge_to_split_0=surface.vIso(bounds[pin])
	edge_to_split_1=surface.vIso(bounds[pin])


#check the edge parameters. not sure if can use p_split directly here, because the first and last parameters are explicitly needed.
u0=edge_to_split_0.FirstParameter
u1=edge_to_split_1.LastParameter

#trim the copies of the selected edge
edge_to_split_0.segment(u0,p_split)
edge_to_split_1.segment(p_split, u1)

# rename clipped edges to mark the step - necessary because the segment() function passes by references
edge_split_0p=edge_to_split_0
edge_split_p1=edge_to_split_1

##############################################################################
#test section
Part.show(face_split.toShape())
Part.show(edge_split_0p.toShape())
Part.show(edge_split_p1.toShape())
#end test section
##############################################################################

#extract poles from the splitter an split curves
face_split_poles=face_split.getPoles()
edge_split_0p_poles=edge_split_0p.getPoles()
edge_split_p1_poles=edge_split_p1.getPoles()

#find corners B and its projected tangent pointing out of the face (this will define the y axis of our sketche)
if pin==0:
	B=face_split_poles[0] #first
	B_tan_y=face_split_poles[1]-face_split_poles[0] #second - first
elif pin==1:
	B=face_split_poles[3] #last
	B_tan_y=face_split_poles[2]-face_split_poles[3] #second to last - last

##############################################################################
#test section
B_y=Part.Line(B, B-B_tan_y)
Part.show(B_y.toShape())
#end test section
##############################################################################

#find all the tangents along the split edge

if split==pin:
	A_check=edge_split_p1_poles[3]
	A_tan_x=edge_split_p1_poles[2]-edge_split_p1_poles[3]
	B_check=edge_split_p1_poles[0]
	B_tan_x_A=edge_split_p1_poles[1]-edge_split_p1_poles[0]
	B_tan_x_C=edge_split_0p_poles[2]-edge_split_0p_poles[3]
	C_check=edge_split_0p_poles[0]
	C_tan_x=edge_split_0p_poles[1]-edge_split_0p_poles[0]
elif split!=pin:
	A_check=edge_split_0p_poles[0]
	A_tan_x=edge_split_0p_poles[1]-edge_split_0p_poles[0]
	B_check=edge_split_0p_poles[3]
	B_tan_x_A=edge_split_0p_poles[2]-edge_split_0p_poles[3]
	B_tan_x_C=edge_split_p1_poles[1]-edge_split_p1_poles[0]
	C_check=edge_split_p1_poles[3]
	C_tan_x=edge_split_p1_poles[2]-edge_split_p1_poles[3]

##############################################################################
#test section
A_x=Part.Line(A_check, A_check+A_tan_x)
B_x_A=Part.Line(B_check, B_check+B_tan_x_A)
B_x_C=Part.Line(B_check, B_check+B_tan_x_C)
C_x=Part.Line(C_check, C_check+C_tan_x)
Part.show(A_x.toShape())
Part.show(B_x_A.toShape())
Part.show(B_x_C.toShape())
Part.show(C_x.toShape())
#end test section
##############################################################################

sketch_A_x=A_tan_x.normalize()
sketch_A_y=A_tan_y.normalize()
sketch_A_z=A_tan_x.cross(A_tan_y).normalize()

sketch_A_matrix=App.Matrix(corner_A_x.x,corner_A_x.y,corner_A_x.z,corner_A.x,
						corner_A_y.x,corner_A_y.y,corner_A_y.z,corner_A.y,
						corner_A_z.x,corner_A_z.y,corner_A_z.z,corner_A.z,
						0,0,0,1)

App.activeDocument().addObject('Sketcher::SketchObject','corner_A_sk')
App.ActiveDocument.corner_A_sk.Placement=App.Placement(corner_A_matrix)
App.ActiveDocument.corner_A_sk.addGeometry(Part.Circle())
App.ActiveDocument.corner_A_sk.addGeometry(Part.Line(Base.Vector(1,1,0),Base.Vector(2,2,0)))
App.ActiveDocument.corner_A_sk.addGeometry(Part.Line(Base.Vector(1,0,0),Base.Vector(2,0,0)))
App.ActiveDocument.corner_A_sk.addGeometry(Part.Line(Base.Vector(0,1,0),Base.Vector(0,2,0)))



'''
#make the face splitting curve along u or v, 
#regenerate the selected edge as two sub-curves.

if split==0:
	face_0=surface.uIso(bounds[0])
	face_1=surface.uIso(bounds[1])
	face_split=surface.uIso(p_split)
	#prepare two copies to avoid passing by reference later
	#this is temporary, copy() function is not available on windows
	edge_to_split_0=surface.vIso(bounds[pin+2])
	edge_to_split_1=surface.vIso(bounds[pin+2])


elif split==1:
	face_0=surface.vIso(bounds[2])
	face_1=surface.vIso(bounds[3])
	face_split=surface.vIso(p_split)
	#prepare two copies to avoid passing by reference later
	#this is temporary, copy() function is not available on windows	
	edge_to_split_0=surface.uIso(bounds[pin])
	edge_to_split_1=surface.uIso(bounds[pin])

#check the edge parameters
u0=edge_to_split_0.FirstParameter
u1=edge_to_split_1.LastParameter

split_point=edge_to_split_0.value((u1-u0)*e_split) # to check against later?

#create the two 'clipped' edges from the (GUI) selected edge
edge_to_split_0.segment(u0,(u1-u0)*e_split)
edge_to_split_1.segment((u1-u0)*e_split, u1)

# rename clipped edges to mark the step - necessary because the segment() function passes by references
edge_split_0=edge_to_split_0
edge_split_1=edge_to_split_1

#extract the control polygons of the five curves
poles_face_0=face_0.getPoles()
poles_face_1=face_1.getPoles()
poles_center=face_split.getPoles()
poles_split_0=edge_split_0.getPoles()
poles_split_1=edge_split_1.getPoles()

#reorder the center and split curves so they end at the split point
if poles_center[0]==split_point:
	poles_center=poles_center[::-1]
elif poles_center[3]==split_point:
	poles_center=poles_center

if poles_split_0[0]==split_point:
	poles_split_0=poles_split_0[::-1]
elif poles_split_0[3]==split_point:
	poles_split_0=poles_split_0
	
if poles_split_1[0]==split_point:
	poles_split_1=poles_split_1[::-1]
elif poles_split_1[3]==split_point:
	poles_split_1=poles_split_1

#reorder the full side curves so they end at the corner with the split curves
#this is the part that should be redone to look up the surface poles directly...sometime
if poles_face_0[0]==poles_split_0[0]:
	poles_face_0=poles_face_0[::-1]
elif poles_face_0[3]==poles_split_0[0]:
	poles_face_0=poles_face_0

if poles_face_1[0]==poles_split_1[0]:
	poles_face_1=poles_face_1[::-1]
elif poles_face_1[3]==poles_split_1[0]:
	poles_face_1=poles_face_1

# group poles into 'node' sketches

if flip==0:
	corner_A=poles_split_0[0]
	corner_A_split=poles_split_0[1]
	corner_A_full=corner_A+poles_face_0[3]-poles_face_0[2]
elif flip==1:
	corner_A=poles_split_1[0]
	corner_A_split=poles_split_1[1]
	corner_A_full=corner_A+poles_face_0[3]-poles_face_0[2]	

corner_A_x=(corner_A_split-corner_A).normalize()
corner_A_y=(corner_A_full-corner_A).normalize()
corner_A_z=corner_A_x.cross(corner_A_y).normalize()

corner_A_matrix=App.Matrix(corner_A_x.x,corner_A_x.y,corner_A_x.z,corner_A.x,
						corner_A_y.x,corner_A_y.y,corner_A_y.z,corner_A.y,
						corner_A_z.x,corner_A_z.y,corner_A_z.z,corner_A.z,
						0,0,0,1)

App.activeDocument().addObject('Sketcher::SketchObject','corner_A_sk')
App.ActiveDocument.corner_A_sk.Placement=App.Placement(corner_A_matrix)
App.ActiveDocument.corner_A_sk.addGeometry(Part.Circle())
App.ActiveDocument.corner_A_sk.addGeometry(Part.Line(Base.Vector(1,1,0),Base.Vector(2,2,0)))
App.ActiveDocument.corner_A_sk.addGeometry(Part.Line(Base.Vector(1,0,0),Base.Vector(2,0,0)))
App.ActiveDocument.corner_A_sk.addGeometry(Part.Line(Base.Vector(0,1,0),Base.Vector(0,2,0)))

App.ActiveDocument.recompute()

# the names face_0, face_1, split_0, split_1 are not consistent across the varying u and v directions of the face/edge selection. 
# this makes the concept of corner_0 and corner_1 inconstistent in terms of the projected sketch orientations


### The section below is the original Part.Line visualization of the curves and the poles.

#the split edges' polygons aren't necessarily planar, so they won't fit on a sketch object
poly_split_0_1=Part.Line(poles_split_0[0], poles_split_0[1])
poly_split_0_2=Part.Line(poles_split_0[1], poles_split_0[2]) 
poly_split_0_3=Part.Line(poles_split_0[2], poles_split_0[3])

poly_split_1_1=Part.Line(poles_split_1[0], poles_split_1[1])
poly_split_1_2=Part.Line(poles_split_1[1], poles_split_1[2]) 
poly_split_1_3=Part.Line(poles_split_1[2], poles_split_1[3])

#the center curve and parallel edges' control points need to be 
#projected out from the surface to build on the other side
poly_center_1=Part.Line(poles_center[0], poles_center[1])
poly_center_2=Part.Line(poles_center[1], poles_center[2])
poly_center_3=Part.Line(poles_center[2], poles_center[3])
poly_proj_tan=poles_center[3]+poles_center[3]-poles_center[2]
poly_center_4=Part.Line(poles_center[3], poly_proj_tan)

poly_face_0_tan=poles_face_0[3]+poles_face_0[3]-poles_face_0[2]
poly_face_0_0=Part.Line(poles_face_0[3], poly_face_0_tan)

poly_face_1_tan=poles_face_1[3]+poles_face_1[3]-poles_face_1[2]
poly_face_1_0=Part.Line(poles_face_1[3], poly_face_1_tan)




Part.show(face_split.toShape())
Part.show(edge_split_0.toShape())
Part.show(edge_split_1.toShape())

Part.show(poly_split_0_1.toShape())
Part.show(poly_split_0_2.toShape())
Part.show(poly_split_0_3.toShape())

Part.show(poly_split_1_1.toShape())
Part.show(poly_split_1_2.toShape())
Part.show(poly_split_1_3.toShape())

Part.show(poly_center_1.toShape())
Part.show(poly_center_2.toShape())
Part.show(poly_center_3.toShape())
Part.show(poly_center_4.toShape())


Part.show(poly_face_0_0.toShape())
Part.show(poly_face_1_0.toShape())
#

'''



